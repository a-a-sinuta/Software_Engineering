# Тема9. Концепции и принципы ООП

----
Отчет по Теме №9 выполнил:

- Синюта Александр Анатольевич
- ПИЭ-21-2

| Задание    | Лаб_раб | Сам_раб |
|------------|---------|--|
| Задание 1  | +       | + |
| Задание 2  | +       |  |
| Задание 3  | +       |  |
| Задание 4  | +       |  |
| Задание 5  | +       |  |


знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:

- к.э.д., доцент Панов М.А.

## Лабораторная работа №1

-----

### Допустим, что вы решили оригинально и немного странно познакомится с человеком. Для этого у вас должен быть написан свой класс на Python, который будет проверять угадал ваше имя человек или нет. Для этого создайте класс, указав в свойствах только имя. Дальше создайте функцию __init__(), а в ней сделайте проверку на то угадал человек ваше имя или нет. Также можете проверить что будет, если в этой функции указав атрибут, который не указан в вашем классе, например, попробуйте вызвать фамилию

```python
class Ivan:
    __slots__ = ['name']
    def __init__(self, name):
            if name == 'Иван':
                self.name = f"Да, я {name}"
            else:
                self.name = f'Я не {name}, а я Иван'

person1 = Ivan('Алексей')
person2 = Ivan('Иван')
print(person1.name)
print(person2.name)

person2.surname = 'Петров'
```

### Результат.

![](https://github.com/a-a-sinuta/Software_Engineering/blob/Tema_9/pic/lab9_1.png)

## Лабораторная работа №2

-----

### Вам дали важное задание, написать продавцу мороженого программу, которая будет писать добавили ли топпинг в мороженое и цену после возможного изменения. Для этого вам нужно написать класс, в котором будет определяться изменили ли состав мороженого или нет. В этом классе реализуйте метод, выводящий на печать «Мороженое с {ТОППИНГ}» в случае наличия добавки, а иначе отобразится следующая фраза: «Обычное мороженое». При этом программа должна воспринимать как топпинг только атрибуты типа string

```python
class Icecream:
    def __init__(self, ingredient=None):
        if isinstance(ingredient, str):
            self.ingredient = ingredient
        else:
            self.ingredient = None

    def composition(self):
        if self.ingredient:
            print(f'Мороженое с {self.ingredient}')
        else:
            print('Обычное мороженое')


icecream = Icecream()
icecream.composition()
icecream = Icecream('шоколадом')
icecream.composition()
icecream = Icecream(5)
icecream.composition()
```

### Результат.

![](https://github.com/a-a-sinuta/Software_Engineering/blob/Tema_9/pic/lab9_2.png)

## Лабораторная работа №3

-----

### Петя – начинающий программист и на занятиях ему сказали реализовать икапсу…что-то. А вы хороший друг Пети и ко всему прочему прекрасно знаете, что икапсу…что-то – это инкапсуляция, поэтому решаете помочь вашему другу с написанием класса с инкапсуляцией. Ваш класс будет не просто инкапсуляцией, а классом с сеттером, геттером и деструктором. После написания класса вам необходимо продемонстрировать что все написанные вами функции работают. Также вас необходимо объяснить Пете почему на скриншоте ниже в консоли выводится ошибка.

```python
class MyClass:
    def __init__(self, value):
        self._value = value

    def set_value(self, value):
        self._value = value

    def get_value(self):
        return self._value

    def del_value(self):
        del self._value

    value = property(get_value, set_value, del_value, "Свойство value" )


obj = MyClass(42)
print(obj.get_value())
obj.set_value(45)
print(obj.get_value())
obj.set_value(100)
print(obj.get_value())
obj.del_value()
print(obj.get_value)
#Потому что этого свойства больше нет
```

### Результат.

![](https://github.com/a-a-sinuta/Software_Engineering/blob/Tema_9/pic/lab9_3.png)

## Лабораторная работа №4

-----

### Вам прекрасно известно, что кошки и собаки являются млекопитающими, но компьютер этого не понимает, поэтому вам нужно написать три класса: Кошки, Собаки, Млекопитающие. И при помощи “наследования” объяснить компьютеру что кошки и собаки – это млекопитающие. Также добавьте какой-нибудь свой атрибут для кошек и собак, чтобы показать, что они чем-то отличаются друг от друга.

```python
class Mammal:
    className = 'Mammal'


class Dog(Mammal):
    species = 'canine'
    sounds = 'wow'


class Cat(Mammal):
    species = 'feline'
    sounds = 'meow'

    
dog = Dog()
print(f'Dog is {dog.className}, but they say {dog.sounds}')
cat = Cat()
print(f'Cat is {cat.className}, but they say {cat.sounds}')

```

### Результат.

![](https://github.com/a-a-sinuta/Software_Engineering/blob/Tema_9/pic/lab9_4.png)

## Лабораторная работа №5

-----

###  На разных языках здороваются по-разному, но суть остается одинаковой, люди друг с другом здороваются. Давайте вместе с вами реализуем программу с полиморфизмом, которая будет описывать всю суть первого предложения задачи. Для этого мы можем выбрать два языка, например, русский и английский и написать для них отдельные классы, в которых будет в виде атрибута слово, которым здороваются на этих языках. А также напишем функцию, которая будет выводить информацию о том, как на этих языках здороваются. Заметьте, что для решения поставленной задачи мы использовали декоратор @staticmethod, поскольку нам не нужны обязательныепараметры-ссылки вроде self

```python
class Russian:
    @staticmethod
    def greeting():
        print('Привет')


class English:
    @staticmethod
    def greeting():
        print('Hello')


def greet(language):
    language.greeting()


ivan = Russian()
greet(ivan)
john = English()
greet(john)

```

### Результат.

![](https://github.com/a-a-sinuta/Software_Engineering/blob/Tema_9/pic/lab9_5.png)

## Самостоятельная работа №1

-----

### Класс Tomato:
1) Создайте класс Tomato
2) Создайте статическое свойство states, которое будет содержать все 
стадии созревания помидора
3) Создайте метод __init__(), внутри которого будут определены два 
динамических свойства: _index (передается параметром) и _state
(принимает первое значение из словаря states). После написания 
этого блока кода в комментарии к нему укажите какими являются 
эти два свойства
4) Создайте метод grow(), который будет переводить томат на 
следующую стадию созревания
5) Создайте метод is_ripe(), который будет проверять, что томат созрел

### Класс TomatoBush:
1) Создайте класс TomatoBush
2) Определите метод __init__(), который будет принимать в качестве 
параметра количество томатов и на его основе будет создавать 
список объектов класса Tomato. Данный список будет храниться 
внутри динамического свойства tomatoes
3) Создайте метод grow_all(), который будет переводить все объекты 
из списка томатов на следующий этап созревания
4) Создайте метод all_are_ripe(), который будет возвращать True, если 
все томаты из списка стали спелыми.
5) Создайте метод give_away_all(), который будет чистить список 
томатов после сбора урожая

### Класс Gardener:
1) Создайте класс Gardener
2) Создайте метод __init__(), внутри которого будут определены два 
динамических свойства: name (передается параметром, является 
публичным) и _plant (принимает объект класса TomatoBush). После 
написания этого блока кода в комментарии к нему укажите какими 
являются эти два свойства
3) Создайте метод work(), который заставляет садовника работать, что 
позволяет растению становиться более зрелым
4) Создайте метод harvest(), который проверяет, все ли плоды созрели. 
Если все, то садовник собирает урожай. Если нет, то метод печатает 
предупреждение
5) Создайте статический метод knowledge_base(), который выведет в 
консоль справку по садоводству

### Тесты:
1) Вызовите справку по садоводству
2) Создайте объекты классов TomatoBush и Gardener
3) Используя объект класса Gardener, поухаживайте за кустом с 
помидорами
4) Попробуйте собрать урожай, когда томаты еще не дозрели. 
Продолжайте ухаживать за ними
5) Соберите урожай

Результатом работы вашей программы будет листинг кода с подробными 
комментариями и скриншоты выполенния всех тестов.

```python
class Tomato:
    states = {'отсутствует': 0, 'цветение': 1, 'зеленый': 2, 'красный': 3}

    def __init__(self, index):
        self._index = index  # защищенный атрибут
        self._state = self.states['отсутствует']    # защищенный атрибут

    def grow(self):
        self._state += 1

    def is_ripe(self):
        if self._state == 3:
            return True
        else:
            return False


class TomatoBush:
    def __init__(self, num):
        self.tomatoes = [Tomato(index) for index in range(num)]

    def grow_all(self):
        for tomato in self.tomatoes:
            tomato.grow()

    def all_are_ripe(self):
        for tomato in self.tomatoes:
            if not (tomato.is_ripe()):
                return False
        return True

    def give_away_all(self):
        self.tomatoes = None


class Gardener:
    def __init__(self, name, plant: TomatoBush):
        self.name = name  # Публичный атрибут
        self._plant = plant  # Защищенный атрибут

    def work(self):
        self._plant.grow_all()

    def harvest(self):
        if self._plant.all_are_ripe():
            self._plant.give_away_all()
        else:
            print('Не все томаты еще созрели')

    @staticmethod
    def knowledge_base():
        print('Справка')
        print('Дана настоящая в том, что садовник являлся с 1964 года по день смерти 21 января 2003\n '
              'года членом садоводческого некоммерческого товарищества "Восход", находящегося в массиве Васкелово\n '
              'Всеволожского района Ленинградской области. Садовник по праву частной собственности\n '
              'принадлежали возведённые в соответствии с Уставом садовый дом и надворные постройки, '
              'которые расположены на участке № 10 вышеуказанного садоводческого некоммерческого товарищества\n '
              '"Восход" Земельный участок, на котором находятся названные строения, являлся собственностью садовника.\n'
              'Задолженностей по членским, целевым взносам и налогам за садовником в садоводческом\n '
              'некоммерческом товариществе не значится.')


Gardener.knowledge_base()
tomatoBash1 = TomatoBush(5)
gardener1 = Gardener('ivan', tomatoBash1)
gardener1.work()
gardener1.harvest()
gardener1.work()
gardener1.work()
gardener1.harvest()

```
### Результат.

![](https://github.com/a-a-sinuta/Software_Engineering/blob/Tema_9/pic/sam9_1.png)


## Выводы

``states = {'отсутствует': 0, 'цветение': 1, 'зеленый': 2, 'красный': 3}`` - словарь с состояниями помидора 

``def __init__(self, index):`` - магический метод для инициализации нового объекта класса, который запускается при создании нового объекта и принимает параметры: self(ссылка на объект(этот параметр мы напрямую не передаем, за нас это автоматически делает Python)) и index. P.s. как конструктор в java

``self._index = index`` - инициализация защищенного атрибута объекта(защищенные атрибуты и методы могут быть доступны только внутри класса или в его подклассах)

``self._state = self.states['отсутствует']`` - присваиваем атрибуту класса первое значение состояния помидора

``def grow(self):`` - метод класс принимает ссылку на объект этого класса. В этом методе мы меняем динамическое свойство _state, добавляя к значению словаря 1 

``def __init__(self, num):`` - инициализация объект класса КустТоматов. В нем мы создаем динамическое свойство куста это список всех томатов которые на нем растут( через цикл создаем нужное количество томатов передавая каждому томату свой индекс) 

``def grow_all(self):`` - в этом методе мы через цикл вызываем у каждого томата метод grow

``def give_away_all(self):`` - в этом методе мы присваиваем значение None нашему списку томатов, тем самым обнуляя его

``def __init__(self, name, plant: TomatoBush):`` - инициализации объекта Садовник. В него мы как обычное передаем self, name(Имя садовника) и экземпляр класса КустТоматов - plant. Указываем это напрямую чтобы можно было удобно использовать методы и атрибуты этого класса"

``@staticmethod`` - пишем для того, чтобы показать что наш следующий метод статический(он не имеет доступа к атрибутам экземпляра класса и не требует создание экземпляра класса для вызова). Поэтому в объявлении метода нам уже не надо принимать self

``Gardener.knowledge_base()`` - запускаем метод из класса Садовник не создавая экземпляра класса, так как этот метод статический

``tomatoBash1 = TomatoBush(5)`` -- создаем Куст томатов на котором растет 5 томатов, после этой строки запускается метод ``__init__`` в классе TomatoBush

``gardener1 = Gardener('ivan', tomatoBash1)`` - создаем садовника по имени Иван, который будет следить за нашим кустом

``gardener1.work()`` - заставляем нашего садовника работать, тем самым наши помидоры растут и принимаю статус - "цветение"

``gardener1.harvest()`` - заставляем садовника проверить не выросли наши помидоры, и так как у нас помидоры пока что имеют только статус "цветение", мы не можем собрать урожай и получаем уведомление о том что еще не все помидоры созрели

``gardener1.harvest()`` - после прошлой проверки мы заставили нашего садовника поработать еще 2 раза, тем самым наши помидоры стали красными и в этот раз садовник смог собрать урожай так как метод all_are_ripe из класса КустТоматов вернул True